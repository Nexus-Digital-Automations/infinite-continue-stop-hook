
/* eslint-disable security/detect-non-literal-fs-filename */

/*
 * Security exceptions: This file operates on trusted agent data structures
 * and validated project files. All filesystem operations use pre-validated
 * paths within project boundaries. Object access patterns are safe as they
 * operate on controlled internal agent data structures with validated keys.
 */
const fs = require('fs');
const crypto = require('crypto');
const Logger = require('./logger');

class AgentManager {
  constructor(todoPath, options = {}) {
    this.todoPath = todoPath;
    this.logger = options.logger || new Logger(process.cwd());
    this.options = {
      maxConcurrentTasks: options.maxConcurrentTasks || 5,
      agentTimeout: options.agentTimeout || 1800000, // 30 minutes
      heartbeatInterval: options.heartbeatInterval || 30000, // 30 seconds
      enableDistributedMode: options.enableDistributedMode !== false,
      ...options,
    };

    // Agent heartbeat tracking
    this.agentHeartbeats = new Map();
    this.heartbeatTimer = null;

    // Agent capability definitions
    this.agentCapabilities = {
      development: ['file-operations', 'linting', 'testing', 'build-fixes', 'refactoring'],
      testing: ['test-creation', 'test-execution', 'coverage-analysis', 'test-debugging'],
      review: ['code-review', 'quality-assessment', 'documentation-review', 'security-audit'],
      research: ['codebase-analysis', 'architecture-research', 'dependency-analysis', 'pattern-investigation'],
      coordination: ['multi-agent-orchestration', 'conflict-resolution', 'task-distribution', 'synchronization'],
      deployment: ['ci-cd', 'deployment-scripts', 'environment-setup', 'monitoring-setup'],
      security: ['vulnerability-scanning', 'auth-implementation', 'secure-coding', 'compliance-checks'],
      performance: ['profiling', 'optimization', 'load-testing', 'memory-analysis'],
    };
  }

  /**
     * Register a new agent in the system
     * @param {Object} agentConfig - Agent configuration
     * @returns {string} Generated agent ID
     */
  async registerAgent(agentConfig) {
    let todoData;
    try {
      todoData = await this.readTodo();
    } catch {
      // If TODO.json doesn't exist, create minimal structure
      todoData = {
        project: 'unknown',
        tasks: [],
        agents: {},
      };
    }

    // Generate unique agent ID
    const agentId = await this.generateAgentId(agentConfig);

    // Initialize agents object if it doesn't exist
    if (!todoData.agents) {
      todoData.agents = {};
    }

    // Create agent entry
    const agent = {
      name: agentConfig.name || `${agentConfig.role} Agent`,
      role: agentConfig.role || 'development',
      specialization: agentConfig.specialization || [],
      status: 'active',
      assignedTasks: [],
      lastHeartbeat: new Date().toISOString(),
      parentAgentId: agentConfig.parentAgentId || null,
      capabilities: this.getCapabilitiesForRole(agentConfig.role),
      workload: 0,
      maxConcurrentTasks: agentConfig.maxConcurrentTasks || this.options.maxConcurrentTasks,
      createdAt: new Date().toISOString(),
      sessionId: agentConfig.sessionId || null,
      metadata: agentConfig.metadata || {},
    };

    // Security: Validate agentId before assignment to prevent object injection
    if (!this.isValidAgentId(agentId)) {
      throw new Error(`Invalid agent ID generated: ${agentId}`);
    }

    // Safe assignment after validation - agentId has been validated against injection attacks
    /* eslint-disable-next-line security/detect-object-injection */
    todoData.agents[agentId] = agent;
    await this.writeTodo(todoData);

    // Start heartbeat monitoring for this agent
    this.startHeartbeatMonitoring(agentId);

    this.logger.addFlow(`Registered agent ${agentId} with role ${agent.role}`);

    return agentId;
  }

  /**
     * Generate unique agent ID
     * @param {Object} agentConfig - Agent configuration
     * @returns {string} Unique agent ID
     */
  async generateAgentId(agentConfig) {
    const sessionId = agentConfig.sessionId || 'session_' + Date.now();
    const role = agentConfig.role || 'dev';
    const timestamp = Date.now();

    // Create short hash for uniqueness
    const hash = crypto.createHash('sha256')
      .update(`${sessionId}-${role}-${timestamp}-${Math.random()}`)
      .digest('hex')
      .substring(0, 8);

    // Format: {role}_{sessionId}_{instance}_{specialization}
    const specialization = agentConfig.specialization?.[0] || 'general';
    const instance = await this.getNextInstanceNumber(role, sessionId);

    return `${role}_${sessionId}_${instance}_${specialization}_${hash}`;
  }

  /**
     * Get next instance number for role/session combination
     * @param {string} role - Agent role
     * @param {string} sessionId - Session ID
     * @returns {number} Next instance number
     */
  async getNextInstanceNumber(role, sessionId) {
    try {
      const todoData = await this.readTodo();
      if (!todoData.agents) {return 1;}

      const existingAgents = Object.keys(todoData.agents)
        .filter(agentId => agentId.startsWith(`${role}_${sessionId}`));

      return existingAgents.length + 1;
    } catch {
      return 1;
    }
  }

  /**
     * Get capabilities for a specific role
     * @param {string} role - Agent role
     * @returns {Array} Array of capabilities
     */
  getCapabilitiesForRole(role) {
    // Security: Validate role against allowed roles to prevent object injection
    if (!role || typeof role !== 'string') {
      this.logger.addFlow(`Invalid role provided: ${role}, using development default`);
      return this.agentCapabilities.development;
    }

    // Whitelist approach: only allow known roles
    const allowedRoles = Object.keys(this.agentCapabilities);
    if (!allowedRoles.includes(role)) {
      this.logger.addFlow(`Unknown role '${role}', using development default`);
      return this.agentCapabilities.development;
    }

    // Safe property access after validation - role has been validated against allowed roles
    return Object.prototype.hasOwnProperty.call(this.agentCapabilities, role)
      /* eslint-disable-next-line security/detect-object-injection */
      ? this.agentCapabilities[role]
      : this.agentCapabilities.development;
  }

  /**
     * Unregister an agent from the system
     * @param {string} agentId - Agent ID to unregister
     * @returns {boolean} Success status
     */
  async unregisterAgent(agentId) {
    const todoData = await this.readTodo();

    // Security: Validate agentId to prevent object injection
    if (!this.isValidAgentId(agentId)) {
      this.logger.logError(new Error('Invalid agent ID'), `unregisterAgent - invalid agentId: ${agentId}`);
      return false;
    }

    if (!todoData.agents || !Object.prototype.hasOwnProperty.call(todoData.agents, agentId)) {
      return false;
    }

    // Release any assigned tasks - agentId has been validated
    /* eslint-disable-next-line security/detect-object-injection */
    const agent = todoData.agents[agentId];
    if (agent.assignedTasks && agent.assignedTasks.length > 0) {
      await this.releaseAllTasksFromAgent(agentId);
    }

    // Remove agent - validated safe operation - agentId has been validated
    /* eslint-disable-next-line security/detect-object-injection */
    delete todoData.agents[agentId];
    await this.writeTodo(todoData);

    // Stop heartbeat monitoring
    this.stopHeartbeatMonitoring(agentId);

    this.logger.addFlow(`Unregistered agent ${agentId}`);

    return true;
  }

  /**
     * Update agent heartbeat
     * @param {string} agentId - Agent ID
     * @returns {boolean} Success status
     */
  async updateAgentHeartbeat(agentId) {
    try {
      const todoData = await this.readTodo();

      // Security: Validate agentId to prevent object injection
      if (!this.isValidAgentId(agentId)) {
        this.logger.logError(new Error('Invalid agent ID'), `updateAgentHeartbeat - invalid agentId: ${agentId}`);
        return false;
      }

      if (todoData.agents && Object.prototype.hasOwnProperty.call(todoData.agents, agentId)) {
        /* eslint-disable security/detect-object-injection */
        todoData.agents[agentId].lastHeartbeat = new Date().toISOString();
        todoData.agents[agentId].status = 'active';
        /* eslint-enable security/detect-object-injection */
        await this.writeTodo(todoData);

        // Update local heartbeat tracking
        this.agentHeartbeats.set(agentId, Date.now());

        return true;
      }

      return false;
    } catch (error) {
      this.logger.logError(error, `updateAgentHeartbeat for ${agentId}`);
      return false;
    }
  }

  /**
     * Reinitialize an agent - renew heartbeat, reset timeout, update configuration
     * @param {string} agentId - Agent ID to reinitialize
     * @param {Object} config - Optional configuration updates
     * @returns {Object} Reinitialization result
     */
  async reinitializeAgent(agentId, config = {}) {
    try {
      const todoData = await this.readTodo();

      // Security: Validate agentId to prevent object injection
      if (!this.isValidAgentId(agentId)) {
        throw new Error(`Invalid agent ID: ${agentId}`);
      }

      if (!todoData.agents || !Object.prototype.hasOwnProperty.call(todoData.agents, agentId)) {
        throw new Error(`Agent ${agentId} not found`);
      }

      /* eslint-disable-next-line security/detect-object-injection */
      const agent = todoData.agents[agentId];
      const currentTime = new Date().toISOString();

      // Update agent configuration with new config if provided
      Object.assign(agent, {
        // Always update these renewal fields
        lastHeartbeat: currentTime,
        status: 'active',
        lastRenewal: currentTime,
        renewalCount: (agent.renewalCount || 0) + 1,

        // Update provided configuration
        ...config,

        // Preserve critical fields unless explicitly overridden
        name: config.name || agent.name,
        role: config.role || agent.role,
        assignedTasks: config.assignedTasks || agent.assignedTasks,
        createdAt: agent.createdAt, // Never change creation time

        // Merge metadata
        metadata: {
          ...agent.metadata,
          ...config.metadata,
          renewedAt: currentTime,
          renewalReason: config.renewalReason || 'Agent reinitialization requested',
        },
      });

      // Update capabilities if role changed
      if (config.role && config.role !== agent.role) {
        agent.capabilities = this.getCapabilitiesForRole(config.role);
      }

      // Save updated agent data
      await this.writeTodo(todoData);

      // Restart heartbeat monitoring for this agent
      this.stopHeartbeatMonitoring(agentId);
      this.startHeartbeatMonitoring(agentId);

      this.logger.addFlow(`Reinitialized agent ${agentId} - heartbeat renewed, timeout reset`);

      return {
        success: true,
        renewed: true,
        agent: agent,
        renewalCount: agent.renewalCount,
        renewedAt: currentTime,
      };

    } catch (error) {
      this.logger.logError(error, `reinitializeAgent for ${agentId}`);
      throw error;
    }
  }

  /**
     * Get active agents
     * @param {Object} filters - Optional filters (role, specialization, etc.)
     * @returns {Array} Array of active agents
     */
  async getActiveAgents(filters = {}) {
    const todoData = await this.readTodo();

    if (!todoData.agents) {
      return [];
    }

    let agents = Object.entries(todoData.agents)
      .map(([agentId, agent]) => ({ agentId, ...agent }))
      .filter(agent => agent.status === 'active');

    // Apply filters
    if (filters.role) {
      agents = agents.filter(agent => agent.role === filters.role);
    }

    if (filters.specialization) {
      agents = agents.filter(agent =>
        agent.specialization.includes(filters.specialization),
      );
    }

    if (filters.capability) {
      agents = agents.filter(agent =>
        agent.capabilities.includes(filters.capability),
      );
    }

    if (filters.maxWorkload !== undefined) {
      agents = agents.filter(agent => agent.workload <= filters.maxWorkload);
    }

    return agents;
  }

  /**
     * Get agent by ID
     * @param {string} agentId - Agent ID
     * @returns {Object|null} Agent object or null if not found
     */
  async getAgent(agentId) {
    const todoData = await this.readTodo();

    // Security: Validate agentId to prevent object injection
    if (!this.isValidAgentId(agentId)) {
      this.logger.logError(new Error('Invalid agent ID'), `getAgent - invalid agentId: ${agentId}`);
      return null;
    }

    if (todoData.agents && Object.prototype.hasOwnProperty.call(todoData.agents, agentId)) {
      /* eslint-disable-next-line security/detect-object-injection */
      return { agentId, ...todoData.agents[agentId] };
    }

    return null;
  }

  /**
     * Update agent workload
     * @param {string} agentId - Agent ID
     * @param {number} workloadDelta - Change in workload (can be negative)
     * @returns {boolean} Success status
     */
  async updateAgentWorkload(agentId, workloadDelta) {
    const todoData = await this.readTodo();

    // Security: Validate agentId to prevent object injection
    if (!this.isValidAgentId(agentId)) {
      this.logger.logError(new Error('Invalid agent ID'), `updateAgentWorkload - invalid agentId: ${agentId}`);
      return false;
    }

    if (todoData.agents && Object.prototype.hasOwnProperty.call(todoData.agents, agentId)) {
      /* eslint-disable security/detect-object-injection */
      todoData.agents[agentId].workload = Math.max(0,
        (todoData.agents[agentId].workload || 0) + workloadDelta,
      );
      /* eslint-enable security/detect-object-injection */
      await this.writeTodo(todoData);
      return true;
    }

    return false;
  }

  /**
     * Check if agent can accept more tasks
     * @param {string} agentId - Agent ID
     * @returns {boolean} True if agent can accept more tasks
     */
  async canAgentAcceptTasks(agentId) {
    const agent = await this.getAgent(agentId);

    if (!agent || agent.status !== 'active') {
      return false;
    }

    return agent.workload < agent.maxConcurrentTasks;
  }

  /**
     * Find best agent for a task
     * @param {Object} task - Task object
     * @param {Array} excludeAgents - Agent IDs to exclude
     * @returns {string|null} Best agent ID or null if none available
     */
  async findBestAgentForTask(task, excludeAgents = []) {
    const activeAgents = await this.getActiveAgents();

    // Filter out excluded agents and agents at capacity
    const availableAgents = activeAgents.filter(agent =>
      !excludeAgents.includes(agent.agentId) &&
            agent.workload < agent.maxConcurrentTasks,
    );

    if (availableAgents.length === 0) {
      return null;
    }

    // Score agents based on task requirements
    const scoredAgents = availableAgents.map(agent => {
      let score = 0;

      // Role match bonus
      if (agent.role === task.mode?.toLowerCase()) {
        score += 50;
      }

      // Specialization match bonus
      if (task.specialization && agent.specialization.includes(task.specialization)) {
        score += 30;
      }

      // Capability match bonus
      if (task.required_capabilities) {
        const matchCount = task.required_capabilities.filter(cap =>
          agent.capabilities.includes(cap),
        ).length;
        score += matchCount * 10;
      }

      // Priority bonus (higher priority tasks to less loaded agents)
      if (task.priority === 'high') {
        score += Math.max(0, 20 - agent.workload * 5);
      }

      // Workload penalty (prefer less loaded agents)
      score -= agent.workload * 2;

      return { ...agent, score };
    });

    // Sort by score (highest first)
    scoredAgents.sort((a, b) => b.score - a.score);

    return scoredAgents[0]?.agentId || null;
  }

  /**
     * Release all tasks from an agent
     * @param {string} agentId - Agent ID
     * @returns {Array} Array of released task IDs
     */
  async releaseAllTasksFromAgent(agentId) {
    const todoData = await this.readTodo();
    const releasedTasks = [];

    // Security: Validate agentId to prevent object injection
    if (!this.isValidAgentId(agentId)) {
      this.logger.logError(new Error('Invalid agent ID'), `releaseAllTasksFromAgent - invalid agentId: ${agentId}`);
      return [];
    }

    if (todoData.agents && Object.prototype.hasOwnProperty.call(todoData.agents, agentId)) {
      /* eslint-disable-next-line security/detect-object-injection */
      const agent = todoData.agents[agentId];

      // Reset task assignments
      if (agent.assignedTasks) {
        agent.assignedTasks.forEach(taskId => {
          const task = todoData.tasks.find(t => t.id === taskId);
          if (task && task.assigned_agent === agentId) {
            task.assigned_agent = null;
            if (task.status === 'in_progress') {
              task.status = 'pending';
            }
            releasedTasks.push(taskId);
          }
        });

        agent.assignedTasks = [];
        agent.workload = 0;
      }

      await this.writeTodo(todoData);
    }

    this.logger.addFlow(`Released ${releasedTasks.length} tasks from agent ${agentId}`);

    return releasedTasks;
  }

  /**
     * Start heartbeat monitoring for an agent
     * @param {string} agentId - Agent ID
     */
  startHeartbeatMonitoring(agentId) {
    this.agentHeartbeats.set(agentId, Date.now());

    // Start global heartbeat checker if not running
    if (!this.heartbeatTimer && this.options.enableDistributedMode) {
      this.heartbeatTimer = setInterval(() => {
        this.checkAgentHeartbeats();
      }, this.options.heartbeatInterval);
    }
  }

  /**
     * Stop heartbeat monitoring for an agent
     * @param {string} agentId - Agent ID
     */
  stopHeartbeatMonitoring(agentId) {
    this.agentHeartbeats.delete(agentId);

    // Stop global timer if no agents are being monitored
    if (this.agentHeartbeats.size === 0 && this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }

  /**
     * Check agent heartbeats and mark stale agents as inactive
     */
  async checkAgentHeartbeats() {
    const now = Date.now();
    const staleAgents = [];

    for (const [agentId, lastHeartbeat] of this.agentHeartbeats.entries()) {
      if (now - lastHeartbeat > this.options.agentTimeout) {
        staleAgents.push(agentId);
      }
    }

    if (staleAgents.length > 0) {
      await this.markAgentsAsInactive(staleAgents);
    }
  }

  /**
     * Mark agents as inactive due to timeout
     * @param {Array} agentIds - Array of agent IDs to mark as inactive
     */
  async markAgentsAsInactive(agentIds) {
    const todoData = await this.readTodo();

    for (const agentId of agentIds) {
      // Security: Validate agentId to prevent object injection
      if (!this.isValidAgentId(agentId)) {
        this.logger.logError(new Error('Invalid agent ID'), `markAgentsAsInactive - invalid agentId: ${agentId}`);
        continue;
      }

      if (todoData.agents && Object.prototype.hasOwnProperty.call(todoData.agents, agentId)) {
        /* eslint-disable security/detect-object-injection */
        todoData.agents[agentId].status = 'inactive';
        todoData.agents[agentId].inactiveReason = 'heartbeat_timeout';
        todoData.agents[agentId].inactiveAt = new Date().toISOString();
        /* eslint-enable security/detect-object-injection */

        // Release tasks from inactive agent
        await this.releaseAllTasksFromAgent(agentId);

        // Stop monitoring this agent
        this.stopHeartbeatMonitoring(agentId);

        this.logger.addFlow(`Marked agent ${agentId} as inactive due to timeout`);
      }
    }

    if (agentIds.length > 0) {
      await this.writeTodo(todoData);
    }
  }

  /**
     * Get agent statistics
     * @returns {Object} Agent statistics
     */
  async getAgentStatistics() {
    const todoData = await this.readTodo();

    if (!todoData.agents) {
      return {
        totalAgents: 0,
        activeAgents: 0,
        inactiveAgents: 0,
        agentsByRole: {},
        totalWorkload: 0,
        averageWorkload: 0,
      };
    }

    const agents = Object.values(todoData.agents);


    const activeAgents = agents.filter(agent => agent.status === 'active');

    const agentsByRole = {};
    let totalWorkload = 0;


    agents.forEach(agent => {
      // Security: Validate agent.role before using as object key to prevent injection
      const role = typeof agent.role === 'string' && agent.role ? agent.role : 'unknown';
      /* eslint-disable-next-line security/detect-object-injection */
      agentsByRole[role] = (agentsByRole[role] || 0) + 1;


      totalWorkload += agent.workload || 0;
    });

    return {
      totalAgents: agents.length,
      activeAgents: activeAgents.length,
      inactiveAgents: agents.length - activeAgents.length,
      agentsByRole,
      totalWorkload,
      averageWorkload: agents.length > 0 ? totalWorkload / agents.length : 0,
    };
  }

  /**
     * Cleanup inactive agents older than specified time
     * @param {number} maxAgeHours - Maximum age in hours for inactive agents
     * @returns {Array} Array of cleaned up agent IDs
     */
  async cleanupInactiveAgents(maxAgeHours = 24) {
    const todoData = await this.readTodo();
    const cleanedUp = [];

    if (!todoData.agents) {
      return cleanedUp;
    }

    const cutoffTime = new Date(Date.now() - (maxAgeHours * 60 * 60 * 1000));

    for (const [agentId, agent] of Object.entries(todoData.agents)) {
      if (agent.status === 'inactive' && agent.inactiveAt) {
        const inactiveTime = new Date(agent.inactiveAt);
        if (inactiveTime < cutoffTime) {
          // Security: Validate agentId before deletion to prevent object injection
          if (!this.isValidAgentId(agentId)) {
            this.logger.logError(new Error('Invalid agent ID'), `cleanupInactiveAgents - invalid agentId: ${agentId}`);
            continue;
          }

          /* eslint-disable-next-line security/detect-object-injection */
          delete todoData.agents[agentId];
          cleanedUp.push(agentId);
        }
      }
    }

    if (cleanedUp.length > 0) {
      await this.writeTodo(todoData);
      this.logger.addFlow(`Cleaned up ${cleanedUp.length} inactive agents`);
    }

    return cleanedUp;
  }

  /**
     * Read TODO.json file
     * @returns {Object} TODO.json data
     */
  readTodo() {
    try {
      const content = fs.readFileSync(this.todoPath, 'utf8');
      const parsed = JSON.parse(content);
      // DEBUG: Temporary logging removed
      return parsed;
    } catch (error) {
      throw new Error(`Failed to read TODO.json: ${error.message}`);
    }
  }

  /**
     * Write TODO.json file
     * @param {Object} data - Data to write
     */
  writeTodo(data) {
    try {
      fs.writeFileSync(this.todoPath, JSON.stringify(data, null, 2), 'utf8');
    } catch (error) {
      throw new Error(`Failed to write TODO.json: ${error.message}`);
    }
  }

  /**
     * Cleanup resources
     */
  /**
   * Validate agent ID to prevent object injection attacks
   * @param {string} agentId - Agent ID to validate
   * @returns {boolean} True if valid agent ID
   */
  isValidAgentId(agentId) {
    // Check basic type and existence
    if (!agentId || typeof agentId !== 'string') {
      return false;
    }

    // Check length (reasonable bounds)
    if (agentId.length < 10 || agentId.length > 200) {
      return false;
    }

    // Check format: role_sessionId_instance_specialization_hash
    const agentIdPattern = /^[a-zA-Z_]+_session_\d+_\d+_[a-zA-Z0-9_]+_[a-f0-9]{8}$/;
    if (!agentIdPattern.test(agentId)) {
      return false;
    }

    // Check for suspicious patterns that could be injection attempts
    const suspiciousPatterns = [
      '__proto__',
      'constructor',
      'prototype',
      '../',
      '..\\',
      '<script',
      'javascript:',
      'eval(',
      'function(',
    ];

    const lowerAgentId = agentId.toLowerCase();
    for (const pattern of suspiciousPatterns) {
      if (lowerAgentId.includes(pattern)) {
        this.logger.logError(new Error('Suspicious agent ID pattern detected'), `agentId: ${agentId}, pattern: ${pattern}`);
        return false;
      }
    }

    return true;
  }

  cleanup() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
    this.agentHeartbeats.clear();
  }
}

module.exports = AgentManager;
