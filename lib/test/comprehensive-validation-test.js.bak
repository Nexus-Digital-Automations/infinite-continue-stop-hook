
const { loggers } = require('./lib/logger');
/**
 * Comprehensive Validation Test Suite
 *
 * Tests all components of the Enhanced Data Schema system:
 * - JSON Schema specification
 * - Index generation utilities
 * - Success criteria templates
 * - Backward compatibility layer
 * - Validation framework
 * - Integration testing
 *
 * @version 1.0.0
 * @module ComprehensiveValidationTest
 */

const FS = require('fs');
const PATH = require('path');

// Import all components
const ValidationFramework = require('../utils/validationFramework');
const IndexGenerator = require('../utils/indexGenerator');
const SuccessCriteriaTemplates = require('../utils/successCriteriaTemplates');
const CompatibilityLayer = require('../utils/compatibilityLayer');

/**
 * ComprehensiveValidationTest class - Full system testing
 */
class ComprehensiveValidationTest {
  constructor() {
    this.logger = this._initializeLogger();
    this.testResults = {
      schema: null,
      indexGenerator: null,
      successCriteria: null,
      compatibilityLayer: null,
      validationFramework: null,
      integration: null,
      summary: {
        totalTests: 0,
        passedTests: 0,
        failedTests: 0,
        errorTests: 0,
      },
    };
    this.startTime = Date.now();
  }

  /**
     * Run all comprehensive tests
     */
  async runAllTests() {
    this.logger.info('Starting comprehensive validation test suite');

    try {
      // Test 1: JSON Schema specification
      this.testResults.schema = await this.testJSONSchema();

      // Test 2: Index generation utilities
      this.testResults.indexGenerator = await this.testIndexGenerator();

      // Test 3: Success criteria templates
      this.testResults.successCriteria = await this.testSuccessCriteriaTemplates();

      // Test 4: Backward compatibility layer
      this.testResults.compatibilityLayer = await this.testCompatibilityLayer();

      // Test 5: Validation framework
      this.testResults.validationFramework = await this.testValidationFramework();

      // Test 6: Integration testing
      this.testResults.integration = await this.testIntegration();

      // Generate final report
      this.generateFinalReport();

    } catch {
      this.logger.error('Critical error in test suite', { error: error.message });
      throw error;
    }
  }

  /**
     * Test JSON Schema specification
     */
  testJSONSchema() {
    this.logger.info('Testing JSON Schema specification');
    const RESULT = { passed: true, tests: [], errors: [] };

    try {
      // Test 1: Schema file exists And is valid JSON
      const schemaPath = PATH.join(__dirname, '../schemas/enhanced-todo-schema.json');

      if (!FS.existsSync(schemaPath)) {
        RESULT.passed = false;
        RESULT.errors.push('Schema file does not exist');
        return result;
      }

      const schemaContent = JSON.parse(FS.readFileSync(schemaPath, 'utf8'));
      RESULT.tests.push({ name: 'Schema file loads', passed: true });

      // Test 2: Required schema properties
      const requiredProps = ['$schema', 'title', 'type', 'properties'];
      for (const prop of requiredProps) {
        const hasProperty = Object.prototype.hasOwnProperty.call(schemaContent, prop);
        RESULT.tests.push({ name: `Has ${prop} property`, passed: hasProperty });
        if (!hasProperty) {result.passed = false;}
      }

      // Test 3: Metadata schema definition
      const hasMetadata = schemaContent.properties?.metadata;
      RESULT.tests.push({ name: 'Metadata schema defined', passed: !!hasMetadata });
      if (!hasMetadata) {result.passed = false;}

      // Test 4: Tasks array schema definition
      const hasTasks = schemaContent.properties?.tasks?.type === 'array';
      RESULT.tests.push({ name: 'Tasks array schema defined', passed: hasTasks });
      if (!hasTasks) {result.passed = false;}

      // Test 5: Indexes schema definition
      const hasIndexes = schemaContent.properties?.indexes;
      RESULT.tests.push({ name: 'Indexes schema defined', passed: !!hasIndexes });
      if (!hasIndexes) {result.passed = false;}

      this.logger.info('JSON Schema tests completed', {
        passed: RESULT.passed,
        testCount: RESULT.tests.length,
      });

    } catch {
      RESULT.passed = false;
      RESULT.errors.push(`Schema test error: ${error.message}`);
    }

    return result;
  }

  /**
     * Test Index Generation Utilities
     */
  async testIndexGenerator() {
    this.logger.info('Testing Index Generation Utilities');
    const RESULT = { passed: true, tests: [], errors: [] };

    try {
      // Test data
      const testData = {
        tasks: [
          {
            id: 'feature_1234567890123_test1abc',
            title: 'Test Feature 1',
            category: 'feature',
            status: 'pending',
            priority: 'high',
          },
          {
            id: 'error_1234567890124_test2def',
            title: 'Test Error 1',
            category: 'error',
            status: 'in_progress',
            priority: 'critical',
          },
        ],
      };

      // Test 1: IndexGenerator instantiation
      const indexGen = new IndexGenerator();
      RESULT.tests.push({ name: 'IndexGenerator instantiation', passed: true });

      // Test 2: Generate indexes
      const indexResult = await indexGen.generateIndexes(testData);
      const hasIndexes = indexResult.indexes && typeof indexResult.indexes === 'object';
      RESULT.tests.push({ name: 'Indexes generated', passed: hasIndexes });
      if (!hasIndexes) {result.passed = false;}

      // Test 3: by_id index
      const byIdIndex = indexResult.indexes.by_id;
      const hasByIdIndex = byIdIndex && typeof byIdIndex['feature_1234567890123_test1abc'] === 'number';
      RESULT.tests.push({ name: 'by_id index populated', passed: hasByIdIndex });
      if (!hasByIdIndex) {result.passed = false;}

      // Test 4: by_status index
      const byStatusIndex = indexResult.indexes.by_status;
      const hasPendingTasks = byStatusIndex && byStatusIndex.pending && byStatusIndex.pending.length > 0;
      RESULT.tests.push({ name: 'by_status index populated', passed: hasPendingTasks });
      if (!hasPendingTasks) {result.passed = false;}

      // Test 5: by_category index
      const byCategoryIndex = indexResult.indexes.by_category;
      const hasFeatureTasks = byCategoryIndex && byCategoryIndex.feature && byCategoryIndex.feature.length > 0;
      RESULT.tests.push({ name: 'by_category index populated', passed: hasFeatureTasks });
      if (!hasFeatureTasks) {result.passed = false;}

      // Test 6: Performance test
      const startTime = Date.now();
      const largeTestData = {
        tasks: Array.from({ length: 1000 }, (_, i) => ({
          id: `test_${Date.now()}_${i.toString().padStart(8, '0')}`,
          title: `Test Task ${i}`,
          category: 'feature',
          status: 'pending',
          priority: 'medium',
        })),
      };
      const _largeIndexedData = await indexGen.generateIndexes(largeTestData);
      const indexingTime = Date.now() - startTime;
      const performancePass = indexingTime < 100; // Should complete within 100ms
      RESULT.tests.push({
        name: 'Performance test (1000 tasks < 100ms)',
        passed: performancePass,
        duration: indexingTime,
      });
      if (!performancePass) {result.passed = false;}

      this.logger.info('Index Generator tests completed', {
        passed: RESULT.passed,
        testCount: RESULT.tests.length,
      });

    } catch {
      RESULT.passed = false;
      RESULT.errors.push(`Index Generator test error: ${error.message}`);
    }

    return result;
  }

  /**
     * Test Success Criteria Templates
     */
  testSuccessCriteriaTemplates() {
    this.logger.info('Testing Success Criteria Templates');
    const RESULT = { passed: true, tests: [], errors: [] };

    try {
      // Test 1: SuccessCriteriaTemplates instantiation
      const templates = new SuccessCriteriaTemplates();
      RESULT.tests.push({ name: 'SuccessCriteriaTemplates instantiation', passed: true });

      // Test 2: Get feature template
      const featureTemplate = templates.getTemplateForCategory('feature');
      const hasFeatureTemplate = featureTemplate && Array.isArray(featureTemplate);
      RESULT.tests.push({ name: 'Feature template available', passed: hasFeatureTemplate });
      if (!hasFeatureTemplate) {result.passed = false;}

      // Test 3: Get error template
      const errorTemplate = templates.getTemplateForCategory('error');
      const hasErrorTemplate = errorTemplate && Array.isArray(errorTemplate);
      RESULT.tests.push({ name: 'Error template available', passed: hasErrorTemplate });
      if (!hasErrorTemplate) {result.passed = false;}

      // Test 4: Generate criteria for task
      const testTask = {
        id: 'feature_1234567890123_test',
        category: 'feature',
        title: 'Test Feature',
      };
      const generatedCriteria = templates.getTemplateForCategory(testTask.category, testTask);
      const hasCriteria = generatedCriteria && generatedCriteria.length > 0;
      RESULT.tests.push({ name: 'Generate criteria for task', passed: hasCriteria });
      if (!hasCriteria) {result.passed = false;}

      // Test 5: Template validation
      const validationResult = templates.validateTaskAgainstTemplate(testTask, generatedCriteria);
      RESULT.tests.push({ name: 'Criteria validation', passed: validationResult.isCompliant });
      if (!validationResult.isCompliant) {result.passed = false;}

      this.logger.info('Success Criteria Templates tests completed', {
        passed: RESULT.passed,
        testCount: RESULT.tests.length,
      });

    } catch {
      RESULT.passed = false;
      RESULT.errors.push(`Success Criteria Templates test error: ${error.message}`);
    }

    return result;
  }

  /**
     * Test Backward Compatibility Layer
     */
  async testCompatibilityLayer() {
    this.logger.info('Testing Backward Compatibility Layer');
    const RESULT = { passed: true, tests: [], errors: [] };

    try {
      // Test 1: CompatibilityLayer instantiation
      const compat = new CompatibilityLayer();
      RESULT.tests.push({ name: 'CompatibilityLayer instantiation', passed: true });

      // Test 2: Legacy format detection
      const legacyData = {
        project: 'test',
        tasks: [
          {
            id: 'task1',
            title: 'Legacy Task',
            status: 'pending',
          },
        ],
      };
      const isLegacy = !compat.isEnhancedFormat(legacyData);
      RESULT.tests.push({ name: 'Legacy format detection', passed: isLegacy });
      if (!isLegacy) {result.passed = false;}

      // Test 3: Enhanced format detection
      const enhancedData = {
        metadata: { schema_version: '2.0.0' },
        indexes: {},
        tasks: [],
      };
      const isEnhanced = compat.isEnhancedFormat(enhancedData);
      RESULT.tests.push({ name: 'Enhanced format detection', passed: isEnhanced });
      if (!isEnhanced) {result.passed = false;}

      // Test 4: Legacy to enhanced migration
      const migratedData = await compat.convertLegacyToEnhanced(legacyData);
      const hasMigrated = migratedData.metadata && migratedData.indexes && migratedData.tasks;
      RESULT.tests.push({ name: 'Legacy to enhanced migration', passed: hasMigrated });
      if (!hasMigrated) {result.passed = false;}

      // Test 5: Enhanced to legacy conversion
      const convertedData = compat.convertEnhancedToLegacy(enhancedData);
      const hasConverted = convertedData && convertedData.tasks && Array.isArray(convertedData.tasks);
      RESULT.tests.push({ name: 'Enhanced to legacy conversion', passed: hasConverted });
      if (!hasConverted) {result.passed = false;}

      this.logger.info('Backward Compatibility Layer tests completed', {
        passed: RESULT.passed,
        testCount: RESULT.tests.length,
      });

    } catch {
      RESULT.passed = false;
      RESULT.errors.push(`Compatibility Layer test error: ${error.message}`);
    }

    return result;
  }

  /**
     * Test Validation Framework
     */
  async testValidationFramework() {
    this.logger.info('Testing Validation Framework');
    const RESULT = { passed: true, tests: [], errors: [] };

    try {
      // Test 1: ValidationFramework instantiation
      const schemaPath = PATH.join(__dirname, '../schemas/enhanced-todo-schema.json');
      const validator = new ValidationFramework({ schemaPath });
      RESULT.tests.push({ name: 'ValidationFramework instantiation', passed: true });

      // Test 2: Framework stats
      const stats = validator.getFrameworkStats();
      const hasStats = stats && stats.initialized && stats.schemaLoaded;
      RESULT.tests.push({ name: 'Framework initialization status', passed: hasStats });
      if (!hasStats) {result.passed = false;}

      // Test 3: Valid data validation
      const validData = {
        metadata: {
          schema_version: '2.0.0',
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        },
        indexes: {
          by_id: {},
          by_status: { pending: [], in_progress: [], completed: [] },
          by_category: { feature: [], error: [], test: [] },
          by_priority: { critical: [], high: [], medium: [], low: [] },
        },
        tasks: [],
      };

      const validationResult = await validator.validateEnhancedData(validData);
      RESULT.tests.push({
        name: 'Valid data validation',
        passed: validationResult.isValid,
        errors: validationResult.errors.length,
      });
      if (!validationResult.isValid) {result.passed = false;}

      // Test 4: Invalid data validation
      const invalidData = {
        // Missing required properties
        tasks: 'not an array',
      };

      const invalidValidationResult = await validator.validateEnhancedData(invalidData);
      const correctlyIdentifiesInvalid = !invalidValidationResult.isValid;
      RESULT.tests.push({
        name: 'Invalid data correctly identified',
        passed: correctlyIdentifiesInvalid,
      });
      if (!correctlyIdentifiesInvalid) {result.passed = false;}

      // Test 5: Individual task validation
      const testTask = {
        id: 'feature_1234567890123_test',
        title: 'Test Feature Task',
        description: 'A test feature task',
        category: 'feature',
        status: 'pending',
        priority: 'medium',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      const taskValidationResult = await validator.validateTask(testTask);
      RESULT.tests.push({
        name: 'Individual task validation',
        passed: taskValidationResult.isValid,
        errors: taskValidationResult.errors.length,
      });
      if (!taskValidationResult.isValid) {result.passed = false;}

      this.logger.info('Validation Framework tests completed', {
        passed: RESULT.passed,
        testCount: RESULT.tests.length,
      });

    } catch {
      RESULT.passed = false;
      RESULT.errors.push(`Validation Framework test error: ${error.message}`);
    }

    return result;
  }

  /**
     * Test Integration of all components
     */
  async testIntegration() {
    this.logger.info('Testing Integration of all components');
    const RESULT = { passed: true, tests: [], errors: [] };

    try {
      // Create sample legacy data
      const legacyData = [
        {
          id: 'feature_1234567890123_integration1',
          title: 'Integration Test Feature',
          description: 'Testing integration capabilities',
          category: 'feature',
          status: 'pending',
          priority: 'high',
        },
        {
          id: 'error_1234567890124_integration2',
          title: 'Integration Test Error',
          description: 'Testing error handling integration',
          category: 'error',
          status: 'in_progress',
          priority: 'critical',
        },
      ];

      // Step 1: Migrate legacy data using CompatibilityLayer
      const compat = new CompatibilityLayer();
      const enhancedData = await compat.convertLegacyToEnhanced(legacyData);
      RESULT.tests.push({ name: 'Legacy data migration', passed: !!enhancedData.metadata });

      // Step 2: Generate indexes using IndexGenerator
      const indexGen = new IndexGenerator();
      const indexResult = await indexGen.generateIndexes(enhancedData);
      const indexedData = { ...enhancedData, indexes: indexResult.indexes };
      const hasGeneratedIndexes = indexResult.indexes && Object.keys(indexResult.indexes.by_id).length > 0;
      RESULT.tests.push({ name: 'Index generation from migrated data', passed: hasGeneratedIndexes });

      // Step 3: Add success criteria using SuccessCriteriaTemplates
      const templates = new SuccessCriteriaTemplates();
      for (const task of indexedData.tasks) {
        const criteria = templates.getTemplateForCategory(task.category, task);
        task.success_criteria = criteria;
      }
      const hasSuccessCriteria = indexedData.tasks.every(task => task.success_criteria && task.success_criteria.length > 0);
      RESULT.tests.push({ name: 'Success criteria generation', passed: hasSuccessCriteria });

      // Step 4: Validate final data using ValidationFramework
      const schemaPath = PATH.join(__dirname, '../schemas/enhanced-todo-schema.json');
      const validator = new ValidationFramework({ schemaPath });
      const validationResult = await validator.validateEnhancedData(indexedData);
      RESULT.tests.push({
        name: 'Complete integrated data validation',
        passed: validationResult.isValid,
        errors: validationResult.errors.length,
        warnings: validationResult.warnings.length,
      });

      // Step 5: Performance test of complete workflow
      const startTime = Date.now();
      const largeLegacyData = Array.from({ length: 500 }, (_, i) => ({
        id: `perf_${Date.now()}_${i.toString().padStart(8, '0')}`,
        title: `Performance Test Task ${i}`,
        category: 'feature',
        status: 'pending',
        priority: 'medium',
      }));

      const perfEnhanced = await compat.convertLegacyToEnhanced(largeLegacyData);
      const perfIndexResult = await indexGen.generateIndexes(perfEnhanced);
      const perfIndexed = { ...perfEnhanced, indexes: perfIndexResult.indexes };
      const perfValidated = await validator.validateEnhancedData(perfIndexed);

      const totalTime = Date.now() - startTime;
      const performancePass = totalTime < 1000; // Should complete within 1 second
      RESULT.tests.push({
        name: 'Performance integration test (500 tasks < 1s)',
        passed: performancePass,
        duration: totalTime,
        isValid: perfValidated.isValid,
      });

      if (!performancePass || !perfValidated.isValid) {result.passed = false;}

      // Determine overall integration success
      const allTestsPassed = RESULT.tests.every(test => test.passed);
      if (!allTestsPassed) {result.passed = false;}

      this.logger.info('Integration tests completed', {
        passed: RESULT.passed,
        testCount: RESULT.tests.length,
      });

    } catch {
      RESULT.passed = false;
      RESULT.errors.push(`Integration test error: ${error.message}`);
    }

    return result;
  }

  /**
     * Generate final comprehensive report
     */
  generateFinalReport() {
    const endTime = Date.now();
    const totalDuration = endTime - this.startTime;

    // Calculate summary statistics
    let totalTests = 0;
    let passedTests = 0;
    let failedTests = 0;

    for (const [component, result] of Object.entries(this.testResults)) {
      if (component === 'summary') {continue;}

      if (result && RESULT.tests) {
        totalTests += RESULT.tests.length;
        passedTests += RESULT.tests.filter(test => test.passed).length;
        failedTests += RESULT.tests.filter(test => !test.passed).length;
      }
    }

    this.testResults.summary = {
      totalTests,
      passedTests,
      failedTests,
      errorTests: Object.values(this.testResults).filter(r => r && r.errors && r.errors.length > 0).length,
      successRate: totalTests > 0 ? (passedTests / totalTests * 100).toFixed(2) : 0,
      totalDuration,
      timestamp: new Date().toISOString(),
    };

    // Generate detailed report
    this.logger.info('='.repeat(80));
    this.logger.info('COMPREHENSIVE VALIDATION TEST SUITE - FINAL REPORT');
    this.logger.info('='.repeat(80));

    this.logger.info(`Total Duration: ${totalDuration}ms`);
    this.logger.info(`Success Rate: ${this.testResults.summary.successRate}%`);
    this.logger.info(`Tests: ${passedTests}/${totalTests} passed`);

    // Component-by-component results
    for (const [component, result] of Object.entries(this.testResults)) {
      if (component === 'summary') {continue;}

      this.logger.info(`\n[${component.toUpperCase()}]`);
      this.logger.info(`Overall: ${result.passed ? 'PASS' : 'FAIL'}`);

      if (result.tests) {
        RESULT.tests.forEach(test => {
          const status = test.passed ? '✓' : '✗';
          const duration = test.duration ? ` (${test.duration}ms)` : '';
          const errors = test.errors ? ` [${test.errors} errors]` : '';
          this.logger.info(`  ${status} ${test.name}${duration}${errors}`);
        });
      }

      if (result.errors && RESULT.errors.length > 0) {
        this.logger.info(`  Errors: ${result.errors.join(', ')}`);
      }
    }

    this.logger.info('\n' + '='.repeat(80));

    // Determine overall test suite result
    const overallSuccess = Object.values(this.testResults)
      .filter(r => r && typeof r.passed === 'boolean')
      .every(r => r.passed);

    if (overallSuccess) {
      this.logger.info('🎉 ALL TESTS PASSED - Enhanced Data Schema system is ready for production!');
    } else {
      this.logger.info('❌ SOME TESTS FAILED - Review errors And fix issues before deployment');
    }

    this.logger.info('='.repeat(80));

    return {
      success: overallSuccess,
      summary: this.testResults.summary,
      detailed: this.testResults,
    };
  }

  /**
     * Initialize logger
     */
  _initializeLogger() {
    return {
      info: (message, meta) => {
        loggers.app.info(`[TEST] ${message}`, meta ? JSON.stringify(meta, null, 2) : '');
        loggers.stopHook.info(`[TEST] ${message}`, meta ? JSON.stringify(meta, null, 2) : '');
      },
      error: (message, meta) => {
        loggers.app.error(`[TEST ERROR] ${message}`, meta ? JSON.stringify(meta, null, 2) : '');
        loggers.stopHook.error(`[TEST ERROR] ${message}`, meta ? JSON.stringify(meta, null, 2) : '');
      },
    };
  }
}

// Export for use as module
module.exports = ComprehensiveValidationTest;

// Run tests if called directly
if (require.main === module) {
  (async () => {
    try {
      const testSuite = new ComprehensiveValidationTest();
      const RESULT = await testSuite.runAllTests();

      // Throw error if tests failed instead of process.exit
      if (!result.success) {
        throw new Error('Test suite failed');
      }
    } catch {
      loggers.app.error('Test suite execution failed:', error);
      loggers.stopHook.error('Test suite execution failed:', error);
      throw error;
    }
  })();
}
