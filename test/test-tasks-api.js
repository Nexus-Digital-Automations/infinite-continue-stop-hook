/**
 * Test script for new TASKS.json API system
 * Validates migration, adapter functionality, And auto-generation
 */

const FS = require('fs').promises;
const path = require('path');
const TASKS_API_ADAPTER = require('../scripts/migrations/tasks-api-adapter');
const { loggers } = require('../lib/logger');

async function testTasksApi(_category = 'general') {
  loggers.stopHook.info('üß™ Testing TASKS.json API system...\n');
  try {
    // Test 1: Verify TASKS.json exists And has correct structure
    loggers.stopHook.info('Test 1: Verifying TASKS.json structure...');
    const tasksPath = path.join(__dirname, 'TASKS.json');
    const tasksData = JSON.parse(await FS.readFile(tasksPath, 'utf8'));

    loggers.stopHook.info(`‚úÖ Schema version: ${tasksData.schema_version}`);
    loggers.stopHook.info(`‚úÖ Total tasks: ${tasksData.metadata.total_tasks}`);
    loggers.stopHook.info(`‚úÖ Tasks by type:`, tasksData.metadata.tasks_by_type);
    loggers.stopHook.info(
      `‚úÖ Migration stats:`,
      tasksData.metadata.migration_stats,
    );

    // Test 2: Verify task types are present
    loggers.stopHook.info('\nTest 2: Verifying task types...');
    const taskTypes = [...new Set(tasksData.tasks.map((t) => t.type))];
    loggers.stopHook.info(`‚úÖ Available task types: ${taskTypes.join(', ')}`);

    // Test 3: Test adapter functionality
    loggers.stopHook.info('\nTest 3: Testing adapter functionality...');
    const adapter = new TASKS_API_ADAPTER();
    const adaptedData = adapter.adaptTasksToFeaturesFormat(tasksData);
    loggers.stopHook.info(
      `‚úÖ Adapted ${adaptedData.features.length} feature tasks`,
    );
    loggers.stopHook.info(`‚úÖ Adapted ${adaptedData.tasks.length} other tasks`);

    // Test 4: Verify auto-generated tasks exist
    loggers.stopHook.info('\nTest 4: Verifying auto-generated tasks...');
    const autoGeneratedTasks = tasksData.tasks.filter((t) => t.auto_generated);
    loggers.stopHook.info(
      `‚úÖ Found ${autoGeneratedTasks.length} auto-generated tasks`,
    );

    const testTasks = autoGeneratedTasks.filter((t) => t.type === 'test');
    const auditTasks = autoGeneratedTasks.filter((t) => t.type === 'audit');
    loggers.stopHook.info(`‚úÖ Test tasks: ${testTasks.length}`);
    loggers.stopHook.info(`‚úÖ Audit tasks: ${auditTasks.length}`);

    // Test 5: Verify task relationships
    loggers.stopHook.info('\nTest 5: Verifying task relationships...');
    const relationshipCount = Object.keys(
      tasksData.task_relationships || {},
    ).length;
    loggers.stopHook.info(`‚úÖ Task relationships defined: ${relationshipCount}`);

    // Test 6: Verify priority system configuration
    loggers.stopHook.info('\nTest 6: Verifying priority system...');
    const priorityOrder = tasksData.priority_system?.order || [];
    loggers.stopHook.info(`‚úÖ Priority order: ${priorityOrder.join(' ‚Üí ')}`);

    // Test 7: Test task sorting by priority
    loggers.stopHook.info('\nTest 7: Testing task priority sorting...');
    const sortedTasks = adapter.sortTasksByPriority([...tasksData.tasks]);
    const taskTypes7 = sortedTasks
      .slice(0, 10)
      .map((t) => `${t.type}(${t.priority})`);
    loggers.stopHook.info(
      `‚úÖ First 10 tasks by priority: ${taskTypes7.join(', ')}`,
    );

    // Test 8: Verify CLAUDE.md compliance features
    loggers.stopHook.info('\nTest 8: Verifying CLAUDE.md compliance...');
    const workflowConfig = tasksData.workflow_config;
    loggers.app.info(
      `‚úÖ Auto-generation enabled: ${workflowConfig.auto_generation_enabled}`,
    );
    loggers.app.info(
      `‚úÖ Mandatory test gate: ${workflowConfig.mandatory_test_gate}`,
    );
    loggers.app.info(
      `‚úÖ Security validation required: ${workflowConfig.security_validation_required}`,
    );

    // Test 9: Test feature task to auto-task generation
    loggers.stopHook.info('\nTest 9: Testing auto-task generation...');
    const testFeature = adapter.adaptFeatureToTask({
      title: 'Test Feature for Auto-Generation',
      description: 'Test feature to validate auto-generation system',
      business_value: 'Validates auto-generation functionality',
      category: 'enhancement',
    });

    const autoTasks = adapter.generateAutoTasksForFeature(testFeature, {
      task_relationships: {},
      metadata: { tasks_by_type: {}, total_tasks: 0 },
    });
    loggers.stopHook.info(
      `‚úÖ Generated ${autoTasks.length} auto-tasks for test feature`,
    );
    loggers.app.info(
      `‚úÖ Auto-task types: ${autoTasks.map((t) => t.type).join(', ')}`,
    );

    // Summary
    loggers.app.info(
      '\nüéâ All tests passed! TASKS.json system is working correctly.',
    );
    loggers.stopHook.info('\nüìä Migration Summary:');
    loggers.stopHook.info(`   ‚Ä¢ Schema version: ${tasksData.schema_version}`);
    loggers.stopHook.info(`   ‚Ä¢ Total tasks: ${tasksData.metadata.total_tasks}`);
    loggers.app.info(
      `   ‚Ä¢ Features migrated: ${tasksData.metadata.migration_stats.features_migrated}`,
    );
    loggers.app.info(
      `   ‚Ä¢ Auto-generated tasks: ${tasksData.metadata.migration_stats.auto_generated_tasks}`,
    );
    loggers.stopHook.info(`   ‚Ä¢ Task types supported: ${taskTypes.length}`);
    loggers.app.info(
      `   ‚Ä¢ Auto-generation enabled: ${workflowConfig.auto_generation_enabled}`,
    );
    loggers.stopHook.info(`   ‚Ä¢ CLAUDE.md compliance: ‚úÖ`);

    return {
      success: true,
      totalTasks: tasksData.metadata.total_tasks,
      taskTypes: taskTypes,
      autoGeneratedTasks: autoGeneratedTasks.length,
      relationshipCount: relationshipCount,
    };
  } catch (error) {
    loggers.stopHook.error('‚ùå Test failed:', error.message);
    throw error;
  }
}

// Run tests if called directly
if (require.main === module) {
  testTasksApi()
    .then((result) => {
      loggers.stopHook.info(
        '\n‚úÖ Test results:',
        JSON.stringify(result, null, 2),
      );
      return result;
    })
    .catch((error) => {
      loggers.stopHook.error('\n‚ùå Test failed:', error.message);
      throw error;
    });
}

module.exports = { testTasksApi };
