/**
 * Jest JSON Reporter for Enhanced CI/CD Integration
 *
 * Generates machine-readable test results in JSON format for CI/CD pipeline processing.
 * Includes detailed test case information, assertion results, And console output.
 *
 * @author CI/CD Integration Agent
 * @version 1.0.0
 * @since 2025-09-23
 */

/* eslint-disable security/detect-non-literal-fs-filename */

const FS = require('fs');
const path = require('path');

class JestJsonReporter {
  constructor(globalConfig, options) {
    this.globalConfig = globalConfig;
    this.options = {
      outputPath: './coverage/reports/test-results.json',
      includeTestCases: true,
      includeAssertionResults: true,
      includeConsoleOutput: true,
      ...options,
    };
  }

  onRunComplete(contexts, results) {
    const report = {
      metadata: {
        timestamp: new Date().toISOString(),
        reporter: 'jest-json-reporter',
        version: '1.0.0',
        generator: 'Enhanced Coverage System',
      },
      summary: {
        numTotalTestSuites: results.numTotalTestSuites,
        numPassedTestSuites: results.numPassedTestSuites,
        numFailedTestSuites: results.numFailedTestSuites,
        numPendingTestSuites: results.numPendingTestSuites,
        numTotalTests: results.numTotalTests,
        numPassedTests: results.numPassedTests,
        numFailedTests: results.numFailedTests,
        numPendingTests: results.numPendingTests,
        numTodoTests: results.numTodoTests,
        startTime: results.startTime,
        endTime: Date.now(),
        duration: Date.now() - results.startTime,
        success: results.success,
      },
      testResults: this.processTestResults(results.testResults),
      coverageMap: results.coverageMap
        ? this.processCoverageMap(results.coverageMap)
        : null,
      environment: {
        node_version: process.version,
        platform: process.platform,
        ci: Boolean(process.env.CI),
        github_actions: Boolean(process.env.GITHUB_ACTIONS),
        github_ref: process.env.GITHUB_REF || null,
        github_sha: process.env.GITHUB_SHA || null,
        github_run_id: process.env.GITHUB_RUN_ID || null,
      },
    };

    // Ensure output directory exists;
    const outputDir = path.dirname(this.options.outputPath);
    if (!FS.existsSync(outputDir)) {
      FS.mkdirSync(outputDir, { recursive: true });
    }

    // Write JSON report
    FS.writeFileSync(this.options.outputPath, JSON.stringify(report, null, 2));

    // Also write a summary file for quick access;
    const summaryPath = path.join(outputDir, 'test-summary.json');
    FS.writeFileSync(
      summaryPath,
      JSON.stringify(
        {
          timestamp: report.metadata.timestamp,
          success: report.summary.success,
          total_tests: report.summary.numTotalTests,
          passed_tests: report.summary.numPassedTests,
          failed_tests: report.summary.numFailedTests,
          duration_ms: report.summary.duration,
          test_suites: report.summary.numTotalTestSuites,
          failed_suites: report.summary.numFailedTestSuites,
        },
        null,
        2
      )
    );
  }

  processTestResults(testResults) {
    return testResults.map((testResult) => {
      const _result = {
        testFilePath: testResult.testFilePath,
        displayName: testResult.displayName,
        status: testResult.numFailingTests > 0 ? 'failed' : 'passed',
        startTime: testResult.perfStats.start,
        endTime: testResult.perfStats.end,
        duration: testResult.perfStats.end - testResult.perfStats.start,
        numTests:
          testResult.numPassingTests +
          testResult.numFailingTests +
          testResult.numPendingTests,
        numPassingTests: testResult.numPassingTests,
        numFailingTests: testResult.numFailingTests,
        numPendingTests: testResult.numPendingTests,
        snapshot: {
          added: testResult.snapshot.added,
          matched: testResult.snapshot.matched,
          unmatched: testResult.snapshot.unmatched,
          updated: testResult.snapshot.updated,
          unchecked: testResult.snapshot.unchecked,
        },
      };

      if (this.options.includeTestCases) {
        result.testCases = testResult.testResults.map((testCase) => ({
          ancestorTitles: testCase.ancestorTitles,
          title: testCase.title,
          fullName: testCase.fullName,
          status: testCase.status,
          duration: testCase.duration || 0,
          numPassingAsserts: testCase.numPassingAsserts || 0,
          location: testCase.location,
        }));
      }

      if (this.options.includeAssertionResults && testResult.testResults) {
        result.failureDetails = testResult.testResults
          .filter((testCase) => testCase.status === 'failed')
          .map((testCase) => ({
            title: testCase.title,
            fullName: testCase.fullName,
            failureMessages: testCase.failureMessages,
            failureDetails: testCase.failureDetails,
          }));
      }

      if (
        this.options.includeConsoleOutput &&
        testResult.console &&
        testResult.console.length > 0
      ) {
        result.consoleOutput = testResult.console.map((log) => ({
          type: log.type,
          message: log.message,
          origin: log.origin,
        }));
      }

      return result;
    });
  }

  processCoverageMap(coverageMap) {
    if (!coverageMap || typeof coverageMap.getCoverageSummary !== 'function') {
      return null;
    }

    try {
      const summary = coverageMap.getCoverageSummary();
      return {
        statements: {
          total: summary.statements.total,
          covered: summary.statements.covered,
          skipped: summary.statements.skipped,
          pct: summary.statements.pct,
        },
        branches: {
          total: summary.branches.total,
          covered: summary.branches.covered,
          skipped: summary.branches.skipped,
          pct: summary.branches.pct,
        },
        functions: {
          total: summary.functions.total,
          covered: summary.functions.covered,
          skipped: summary.functions.skipped,
          pct: summary.functions.pct,
        },
        lines: {
          total: summary.lines.total,
          covered: summary.lines.covered,
          skipped: summary.lines.skipped,
          pct: summary.lines.pct,
        },
      };
    } catch (_) {
      return {
        error: 'Failed to process coverage map',
        message: error.message,
      };
    }
  }
}

module.exports = JestJsonReporter;
