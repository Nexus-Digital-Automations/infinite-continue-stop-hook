/* eslint-disable no-console, security/detect-non-literal-fs-filename, security/detect-object-injection */
/**
 * Fix syntax errors introduced by parameter additions in incorrect locations
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class SyntaxErrorFixer {
  constructor() {
    this.fixes = 0;
    this.filesModified = [];
  }

  getAllJSFiles() {
    try {
      const _result = execSync(
        'find . -name "*.js" -not -path "./node_modules/*" -not -path "./coverage/*" -not -path "./.git/*"',
        { encoding: 'utf-8' }
      );

      return result
        .split('\n')
        .filter((f) => f && f.endsWith('.js'))
        .map((f) => path.resolve(f.replace('./', '')));
    } catch (_) {
      console.error('Failed to get JS files:', error.message);
      return [];
    }
  }

  fixFile(_filePath) {
    const content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n');
    let modified = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Fix: Remove invalid parameters in if conditions
      // Pattern: if (condition, parameter)
      const ifMatch = line.match(
        /if\s*\([^)]+,\s*(agentId|filePath|category[^)]*|validationResults[^)]*)\s*\)/
      );
      if (ifMatch) {
        // Remove the extra parameter from the condition
        lines[i] = line.replace(
          /,\s*(agentId|filePath|category[^,)]*|validationResults[^,)]*)\s*\)/,
          ')'
        );
        modified = true;
        this.fixes++;
        console.log(
          `  ‚úì Fixed if condition at line ${i + 1}: removed ${ifMatch[1]}`
        );
      }

      // Fix: Remove invalid parameters in for loops
      // Pattern: for (..., parameter)
      const forMatch = line.match(
        /for\s*\([^)]+,\s*(agentId|filePath|category[^)]*|validationResults[^)]*)\s*\)/
      );
      if (forMatch) {
        lines[i] = line.replace(
          /,\s*(agentId|filePath|category[^,)]*|validationResults[^,)]*)\s*\)/,
          ')'
        );
        modified = true;
        this.fixes++;
        console.log(
          `  ‚úì Fixed for loop at line ${i + 1}: removed ${forMatch[1]}`
        );
      }

      // Fix: Remove invalid parameters in function calls
      // Pattern: someFunction(param1, param2, invalidParam)
      const callMatch = line.match(
        /([a-zA-Z_][a-zA-Z0-9_]*)\s*\([^)]*,\s*(agentId|filePath|category\s*=\s*'[^']*'|validationResults\s*=\s*\{[^}]*\})\s*\)/
      );
      if (callMatch && !line.includes('function') && !line.includes('=>')) {
        lines[i] = line.replace(
          /,\s*(agentId|filePath|category\s*=\s*'[^']*'|validationResults\s*=\s*\{[^}]*\})\s*\)/,
          ')'
        );
        modified = true;
        this.fixes++;
        console.log(
          `  ‚úì Fixed function call at line ${i + 1}: removed parameter from ${callMatch[1]}`
        );
      }

      // Fix: Remove parameters added to catch blocks incorrectly
      // Pattern: catch (_error, parameter)
      const catchMatch = line.match(
        /catch\s*\(\s*_error\s*,\s*(agentId|filePath|category[^)]*|validationResults[^)]*)\s*\)/
      );
      if (catchMatch) {
        lines[i] = line.replace(
          /,\s*(agentId|filePath|category[^,)]*|validationResults[^,)]*)\s*\)/,
          ')'
        );
        modified = true;
        this.fixes++;
        console.log(
          `  ‚úì Fixed catch block at line ${i + 1}: removed ${catchMatch[1]}`
        );
      }

      // Fix: Remove parameters added incorrectly to array destructuring or other contexts
      // Pattern: const [item] = array, parameter;
      const destructureMatch = line.match(
        /const\s+\[[^\]]+\]\s*=\s*[^,]+,\s*(agentId|filePath|category[^,]*|validationResults[^,]*)/
      );
      if (destructureMatch) {
        lines[i] = line.replace(
          /,\s*(agentId|filePath|category[^,]*|validationResults[^,]*)/,
          ''
        );
        modified = true;
        this.fixes++;
        console.log(
          `  ‚úì Fixed destructuring at line ${i + 1}: removed ${destructureMatch[1]}`
        );
      }

      // Fix: Duplicate constructor parameters
      if (
        line.includes('constructor(') &&
        line.includes('agentId') &&
        line.includes('filePath')
      ) {
        const cleaned = line
          .replace(/, agentId[^,)]*/, '')
          .replace(/, filePath[^,)]*/, '')
          .replace(/, category[^,)]*/, '')
          .replace(/, validationResults[^,)]*/, '');
        if (cleaned !== line) {
          lines[i] = cleaned;
          modified = true;
          this.fixes++;
          console.log(`  ‚úì Cleaned constructor parameters at line ${i + 1}`);
        }
      }
    }

    if (modified) {
      fs.writeFileSync(filePath, lines.join('\n'));
      this.filesModified.push(_filePath);
      return true;
    }

    return false;
  }

  run() {
    console.log('üîß Fixing syntax errors from parameter additions...\n');

    const jsFiles = this.getAllJSFiles();
    console.log(`üìä Found ${jsFiles.length} JavaScript files to check\n`);

    for (const filePath of jsFiles) {
      const relativePath = path.relative(process.cwd(), _filePath);
      console.log(`üîç Checking: ${relativePath}`);

      try {
        if (this.fixFile(_filePath)) {
          console.log(`‚úÖ Fixed syntax errors in: ${relativePath}\n`);
        } else {
          console.log(`‚úÖ No syntax errors found in: ${relativePath}\n`);
        }
      } catch (_) {
        console.error(
          `‚ùå Error processing ${relativePath}: ${error.message}\n`
        );
      }
    }

    this.generateReport();
  }

  generateReport() {
    console.log('\nüìä Syntax Error Fix Report:');
    console.log('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
    console.log('‚îÇ Metric                  ‚îÇ Count    ‚îÇ');
    console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');
    console.log(
      `‚îÇ Total syntax fixes      ‚îÇ ${this.fixes.toString().padEnd(8)} ‚îÇ`
    );
    console.log(
      `‚îÇ Files modified          ‚îÇ ${this.filesModified.length.toString().padEnd(8)} ‚îÇ`
    );
    console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

    if (this.filesModified.length > 0) {
      console.log('\nüìÅ Modified files:');
      for (const filePath of this.filesModified) {
        console.log(`  ‚úÖ ${path.relative(process.cwd(), _filePath)}`);
      }
    }

    console.log('\nüéØ Syntax error fixing complete!');
  }
}

// Run the fixer;
const fixer = new SyntaxErrorFixer();
fixer.run();
