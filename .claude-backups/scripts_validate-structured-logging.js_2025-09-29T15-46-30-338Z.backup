/**
 * Structured Logging and Observability Validation Script
 *
 * Validates implementation against 25-point success criteria for:
 * Feature: Add Structured Logging and Observability (feature_1759082400000_struct_logging)
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class StructuredLoggingValidator {
  constructor() {
    this.results = [];
    this.passedCriteria = 0;
    this.totalCriteria = 25;
    this.projectRoot = process.cwd();
  }

  /**
   * Run complete validation suite
   */
  async validate() {
    console.log(
      '🔍 Validating Structured Logging and Observability Implementation'
    );
    console.log('==========================================\n');

    // Core Implementation Criteria (1-10)
    await this.validateCoreImplementation();

    // Production Readiness Criteria (11-15)
    await this.validateProductionReadiness();

    // Observability and Monitoring Criteria (16-20)
    await this.validateObservabilityFeatures();

    // Security and Compliance Criteria (21-25)
    await this.validateSecurityCompliance();

    // Generate final report
    this.generateFinalReport();

    return this.passedCriteria === this.totalCriteria;
  }

  /**
   * Validate core structured logging implementation (Criteria 1-10)
   */
  async validateCoreImplementation() {
    console.log('📋 Core Implementation Validation (Criteria 1-10)');
    console.log('================================================\n');

    // Criterion 1: Structured JSON logging with Pino
    this.validateCriterion(
      1,
      'Structured JSON logging implemented with Pino',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return content.includes('pino') && content.includes('JSON');
      }
    );

    // Criterion 2: Console.log statements replaced in core files
    this.validateCriterion(
      2,
      'Console.log statements replaced in taskmanager-api.js and stop-hook.js',
      () => {
        const taskManagerPath = path.join(
          this.projectRoot,
          'taskmanager-api.js'
        );
        const stopHookPath = path.join(this.projectRoot, 'stop-hook.js');

        const taskManagerContent = fs.readFileSync(taskManagerPath, 'utf8');
        const stopHookContent = fs.readFileSync(stopHookPath, 'utf8');

        // Check that loggers.app or loggers.stopHook are used instead of console
        const hasStructuredLogging =
          taskManagerContent.includes('loggers.app') &&
          stopHookContent.includes('loggers.stopHook');

        return hasStructuredLogging;
      }
    );

    // Criterion 3: Contextual logging with metadata
    this.validateCriterion(
      3,
      'Contextual logging with consistent metadata fields implemented',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('createContextLogger') &&
          content.includes('agentId') &&
          content.includes('taskId') &&
          content.includes('operationId')
        );
      }
    );

    // Criterion 4: Error logging with stack traces
    this.validateCriterion(
      4,
      'Error logging with stack traces and categorization implemented',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('logError') &&
          content.includes('stack') &&
          content.includes('categorizeError')
        );
      }
    );

    // Criterion 5: Performance timing utilities
    this.validateCriterion(
      5,
      'Performance timing utilities with operation measurement',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('timeOperation') &&
          content.includes('duration_ms') &&
          content.includes('hrtime')
        );
      }
    );

    // Criterion 6: API call logging with sensitive data sanitization
    this.validateCriterion(
      6,
      'API call logging with sensitive data sanitization',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('logApiCall') &&
          content.includes('sanitized') &&
          content.includes('REDACTED')
        );
      }
    );

    // Criterion 7: Specialized component loggers
    this.validateCriterion(
      7,
      'Specialized loggers for different components (app, taskManager, agent, etc.)',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('taskManager:') &&
          content.includes('agent:') &&
          content.includes('validation:') &&
          content.includes('performance:') &&
          content.includes('security:')
        );
      }
    );

    // Criterion 8: Legacy logger backward compatibility
    this.validateCriterion(
      8,
      'Legacy logger class for backward compatibility with stop hook',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('LegacyLogger') &&
          content.includes('logInput') &&
          content.includes('logProjectState')
        );
      }
    );

    // Criterion 9: Environment-based configuration
    this.validateCriterion(
      9,
      'Environment-based logging configuration (development vs production)',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('NODE_ENV') &&
          content.includes('production') &&
          content.includes('transport')
        );
      }
    );

    // Criterion 10: Log level configuration
    this.validateCriterion(
      10,
      'Configurable log levels with environment variable support',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('LOG_LEVEL') &&
          content.includes('level:') &&
          content.includes('info') &&
          content.includes('debug')
        );
      }
    );
  }

  /**
   * Validate production readiness (Criteria 11-15)
   */
  async validateProductionReadiness() {
    console.log('\n🏭 Production Readiness Validation (Criteria 11-15)');
    console.log('==================================================\n');

    // Criterion 11: Production configuration file
    this.validateCriterion(
      11,
      'Production logging configuration file created',
      () => {
        const configPath = path.join(
          this.projectRoot,
          'config',
          'logging-production.js'
        );
        return fs.existsSync(configPath);
      }
    );

    // Criterion 12: Production logger factory
    this.validateCriterion(
      12,
      'Production logger factory with enhanced capabilities',
      () => {
        const prodLoggerPath = path.join(
          this.projectRoot,
          'lib',
          'logger-production.js'
        );
        if (!fs.existsSync(prodLoggerPath)) {
          return false;
        }

        const content = fs.readFileSync(prodLoggerPath, 'utf8');
        return (
          content.includes('ProductionLoggerFactory') &&
          content.includes('enhanceLogger') &&
          content.includes('sanitizeLogData')
        );
      }
    );

    // Criterion 13: Log rotation and retention
    this.validateCriterion(
      13,
      'Log rotation and retention configuration',
      () => {
        const configPath = path.join(
          this.projectRoot,
          'config',
          'logging-production.js'
        );
        if (!fs.existsSync(configPath)) {
          return false;
        }

        const content = fs.readFileSync(configPath, 'utf8');
        return (
          content.includes('logRotationConfig') &&
          content.includes('maxSize') &&
          content.includes('maxFiles') &&
          content.includes('maxAge')
        );
      }
    );

    // Criterion 14: Production initialization script
    this.validateCriterion(
      14,
      'Production logging initialization script created',
      () => {
        const scriptPath = path.join(
          this.projectRoot,
          'scripts',
          'initialize-production-logging.js'
        );
        return fs.existsSync(scriptPath);
      }
    );

    // Criterion 15: Environment template and deployment configs
    this.validateCriterion(
      15,
      'Environment templates and deployment configurations created',
      () => {
        const scriptPath = path.join(
          this.projectRoot,
          'scripts',
          'initialize-production-logging.js'
        );
        if (!fs.existsSync(scriptPath)) {
          return false;
        }

        const content = fs.readFileSync(scriptPath, 'utf8');
        return (
          content.includes('createEnvironmentTemplate') &&
          content.includes('createDockerLoggingConfig') &&
          content.includes('createSystemdServiceTemplate')
        );
      }
    );
  }

  /**
   * Validate observability and monitoring features (Criteria 16-20)
   */
  async validateObservabilityFeatures() {
    console.log(
      '\n📊 Observability and Monitoring Validation (Criteria 16-20)'
    );
    console.log('==========================================================\n');

    // Criterion 16: System health metrics
    this.validateCriterion(
      16,
      'System health metrics collection (memory, CPU, uptime)',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('systemHealth') &&
          content.includes('memoryUsage') &&
          content.includes('cpuUsage') &&
          content.includes('uptime')
        );
      }
    );

    // Criterion 17: Business metrics tracking
    this.validateCriterion(
      17,
      'Business metrics tracking for task operations',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('business:') &&
          content.includes('taskCreated') &&
          content.includes('taskCompleted') &&
          content.includes('agentInitialized') &&
          content.includes('validationRun')
        );
      }
    );

    // Criterion 18: Alert detection and thresholds
    this.validateCriterion(
      18,
      'Alert detection patterns with configurable thresholds',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('alerts:') &&
          content.includes('highMemoryUsage') &&
          content.includes('errorRateSpike') &&
          content.includes('taskFailureRate') &&
          content.includes('threshold')
        );
      }
    );

    // Criterion 19: Error categorization and trending
    this.validateCriterion(
      19,
      'Error categorization and trend analysis',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('errorTracking:') &&
          content.includes('categorizeError') &&
          content.includes('trackErrorTrend') &&
          content.includes('severity')
        );
      }
    );

    // Criterion 20: Health check endpoints
    this.validateCriterion(
      20,
      'Health check utilities for system monitoring',
      () => {
        const loggerPath = path.join(this.projectRoot, 'lib', 'logger.js');
        const content = fs.readFileSync(loggerPath, 'utf8');
        return (
          content.includes('healthCheck:') &&
          content.includes('performSystemCheck') &&
          content.includes('status')
        );
      }
    );
  }

  /**
   * Validate security and compliance (Criteria 21-25)
   */
  async validateSecurityCompliance() {
    console.log('\n🔒 Security and Compliance Validation (Criteria 21-25)');
    console.log('====================================================\n');

    // Criterion 21: Sensitive data redaction
    this.validateCriterion(
      21,
      'Sensitive data redaction in production logs',
      () => {
        const configPath = path.join(
          this.projectRoot,
          'config',
          'logging-production.js'
        );
        if (!fs.existsSync(configPath)) {
          return false;
        }

        const content = fs.readFileSync(configPath, 'utf8');
        return (
          content.includes('redactFields') &&
          content.includes('password') &&
          content.includes('token') &&
          content.includes('secret')
        );
      }
    );

    // Criterion 22: Audit logging for compliance
    this.validateCriterion(
      22,
      'Audit logging for GDPR/SOX/HIPAA compliance',
      () => {
        const prodLoggerPath = path.join(
          this.projectRoot,
          'lib',
          'logger-production.js'
        );
        if (!fs.existsSync(prodLoggerPath)) {
          return false;
        }

        const content = fs.readFileSync(prodLoggerPath, 'utf8');
        return (
          content.includes('auditLog') &&
          content.includes('GDPR') &&
          content.includes('compliance')
        );
      }
    );

    // Criterion 23: Data retention policies
    this.validateCriterion(
      23,
      'Data retention policies configured for different log types',
      () => {
        const configPath = path.join(
          this.projectRoot,
          'config',
          'logging-production.js'
        );
        if (!fs.existsSync(configPath)) {
          return false;
        }

        const content = fs.readFileSync(configPath, 'utf8');
        return (
          content.includes('dataRetention') &&
          content.includes('auditLogDays') &&
          content.includes('performanceLogDays') &&
          content.includes('errorLogDays')
        );
      }
    );

    // Criterion 24: External monitoring integrations
    this.validateCriterion(
      24,
      'External monitoring system integrations (CloudWatch, Datadog, ELK)',
      () => {
        const configPath = path.join(
          this.projectRoot,
          'config',
          'logging-production.js'
        );
        if (!fs.existsSync(configPath)) {
          return false;
        }

        const content = fs.readFileSync(configPath, 'utf8');
        return (
          content.includes('cloudwatch') &&
          content.includes('datadog') &&
          content.includes('elk') &&
          content.includes('prometheus')
        );
      }
    );

    // Criterion 25: Performance optimization for production
    this.validateCriterion(
      25,
      'Performance optimizations for high-throughput production logging',
      () => {
        const configPath = path.join(
          this.projectRoot,
          'config',
          'logging-production.js'
        );
        if (!fs.existsSync(configPath)) {
          return false;
        }

        const content = fs.readFileSync(configPath, 'utf8');
        return (
          content.includes('performanceConfig') &&
          content.includes('async') &&
          content.includes('buffer') &&
          content.includes('sampling')
        );
      }
    );
  }

  /**
   * Validate a single criterion
   */
  validateCriterion(number, description, validator) {
    try {
      const passed = validator();
      const status = passed ? '✅ PASS' : '❌ FAIL';
      console.log(
        `${number.toString().padStart(2, '0')}. ${status} - ${description}`
      );

      this.results.push({
        number,
        description,
        passed,
        status: passed ? 'PASS' : 'FAIL',
      });

      if (passed) {
        this.passedCriteria++;
      }
    } catch (_) {
      console.log(
        `${number.toString().padStart(2, '0')}. ❌ ERROR - ${description}`
      );
      console.log(`    Error: ${error.message}`);

      this.results.push({
        number,
        description,
        passed: false,
        status: 'ERROR',
        error: error.message,
      });
    }
  }

  /**
   * Generate final validation report
   */
  generateFinalReport() {
    console.log('\n' + '='.repeat(60));
    console.log('📋 STRUCTURED LOGGING VALIDATION SUMMARY');
    console.log('='.repeat(60));

    const passRate = ((this.passedCriteria / this.totalCriteria) * 100).toFixed(
      1
    );
    console.log(
      `\n📊 Results: ${this.passedCriteria}/${this.totalCriteria} criteria passed (${passRate}%)`
    );

    if (this.passedCriteria === this.totalCriteria) {
      console.log('\n🎉 SUCCESS: All structured logging criteria met!');
      console.log('✅ Feature implementation is complete and production-ready');
    } else {
      console.log('\n⚠️  INCOMPLETE: Some criteria not met');
      console.log('❌ Failed criteria:');

      this.results
        .filter((r) => !r.passed)
        .forEach((result) => {
          console.log(
            `   ${result.number.toString().padStart(2, '0')}. ${result.description}`
          );
          if (result.error) {
            console.log(`       Error: ${result.error}`);
          }
        });
    }

    // Categories breakdown
    const coreResults = this.results.slice(0, 10);
    const prodResults = this.results.slice(10, 15);
    const obsResults = this.results.slice(15, 20);
    const secResults = this.results.slice(20, 25);

    console.log('\n📈 Category Breakdown:');
    console.log(
      `   Core Implementation (1-10):     ${coreResults.filter((r) => r.passed).length}/10`
    );
    console.log(
      `   Production Readiness (11-15):   ${prodResults.filter((r) => r.passed).length}/5`
    );
    console.log(
      `   Observability Features (16-20): ${obsResults.filter((r) => r.passed).length}/5`
    );
    console.log(
      `   Security & Compliance (21-25):  ${secResults.filter((r) => r.passed).length}/5`
    );

    // Generate detailed report file
    this.generateDetailedReport();

    console.log(
      '\n📝 Detailed report saved to: structured-logging-validation-report.json'
    );
    console.log('='.repeat(60));
  }

  /**
   * Generate detailed JSON report
   */
  generateDetailedReport() {
    const report = {
      timestamp: new Date().toISOString(),
      feature:
        'Add Structured Logging and Observability (feature_1759082400000_struct_logging)',
      validation_version: '1.0.0',
      summary: {
        total_criteria: this.totalCriteria,
        passed_criteria: this.passedCriteria,
        pass_rate_percent: (
          (this.passedCriteria / this.totalCriteria) *
          100
        ).toFixed(1),
        overall_status:
          this.passedCriteria === this.totalCriteria
            ? 'COMPLETE'
            : 'INCOMPLETE',
      },
      categories: {
        core_implementation: {
          range: '1-10',
          passed: this.results.slice(0, 10).filter((r) => r.passed).length,
          total: 10,
        },
        production_readiness: {
          range: '11-15',
          passed: this.results.slice(10, 15).filter((r) => r.passed).length,
          total: 5,
        },
        observability_features: {
          range: '16-20',
          passed: this.results.slice(15, 20).filter((r) => r.passed).length,
          total: 5,
        },
        security_compliance: {
          range: '21-25',
          passed: this.results.slice(20, 25).filter((r) => r.passed).length,
          total: 5,
        },
      },
      detailed_results: this.results,
      environment: {
        node_version: process.version,
        platform: process.platform,
        project_root: this.projectRoot,
      },
    };

    fs.writeFileSync(
      path.join(this.projectRoot, 'structured-logging-validation-report.json'),
      JSON.stringify(report, null, 2)
    );
  }
}

// Run validation if called directly
async function main() {
  const validator = new StructuredLoggingValidator();
  const success = await validator.validate();

  process.exit(success ? 0 : 1);
}

if (require.main === module) {
  main().catch((error) => {
    console.error('Validation failed:', error);
    process.exit(1);
  });
}

module.exports = {
  StructuredLoggingValidator,
  main,
};
