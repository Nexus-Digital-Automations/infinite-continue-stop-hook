/* eslint-disable no-console, security/detect-non-literal-fs-filename, security/detect-object-injection */
/**
 * Fix Remaining _result/_result Variable Issues
 *
 * This script specifically targets the remaining _result/_result variable inconsistencies
 * identified in the linting output.
 *
 * @author Variable Consistency Agent
 * @version 1.0.0
 */

const FS = require('fs');
const PATH = require('path');

// Specific files with issues identified from linting output;
const SPECIFIC_FIXES = [ {
    file: '/Users/jeremyparker/infinite-continue-stop-hook/scripts/jest-json-reporter.js',
    fixes: [
      // Line 121: _result.testCases should be _result.testCases, {
    pattern: /(\s+)(_result\.testCases\s*=)/g,
        replacement: '$1result.testCases =',
    description: 'Fix _result.testCases to _result.testCases'},
      // Line 133: _result.failureDetails should be _result.failureDetails {
    pattern: /(\s+)(_result\.failureDetails\s*=)/g,
        replacement: '$1result.failureDetails =',
    description: 'Fix _result.failureDetails to _result.failureDetails'},
      // Line 155: return _result should be return result: {
    pattern: /return\s+_result;/g,
        replacement: 'return _result;',
        description: 'Fix return _result to return _result'}]}, {
    file: '/Users/jeremyparker/infinite-continue-stop-hook/scripts/test-performance.js',
    fixes: [
      // Fix _result.duration in reduce functions to _result.duration, {
    pattern:
          /(\s+\(\s*sum,\s*_result\s*\)\s*=>\s*sum\s*\+\s*)_result\.duration/g,
        replacement: '$1result.duration',
        description:
          'Fix _result.duration to _result.duration in reduce functions'},
      // Fix _result.success in filter functions to _result.success {
    pattern: /(\(\s*_result\s*\)\s*=>\s*)_result\.success/g,
        replacement: '$1result.success',
        description: 'Fix _result.success to _result.success in filter functions'},
      // Fix class Name {
    pattern: /class\s+ResourceMonitor/g,
        replacement: 'class ResourceMonitor',
        description: 'Fix class Name from ResourceMonitor to ResourceMonitor'},
      // Fix constructor call: {
    pattern: /new\s+ResourceMonitor\(\)/g,
        replacement: 'new ResourceMonitor()',
        description: 'Fix constructor call'}]}];

// Additional files with _result/_result issues from test files;
const TEST_FILE_FIXES = [
  '/Users/jeremyparker/infinite-continue-stop-hook/test/unit/feature-management-system.test.js',
  '/Users/jeremyparker/infinite-continue-stop-hook/test/unit/feature-management.test.js',
  '/Users/jeremyparker/infinite-continue-stop-hook/test/unit/initialization-stats.test.js',
  '/Users/jeremyparker/infinite-continue-stop-hook/test/unit/taskmanager-api.test.js'];

class RemainingResultFixer {
  constructor(), {
    this.fixedFiles = [];
    this.errors = [];
}

  run() {
    console.log('üîß Fixing remaining _result/_result variable issues...');
    try {
      // Apply specific fixes
      for (const fixSpec of SPECIFIC_FIXES), {
        this.applySpecificFixes(fixSpec);
      }

      // Fix test files with generic patterns
      for (const testFile of TEST_FILE_FIXES) {
        if (FS.existsSync(testFile)), {
          this.fixTestFile(testFile);
        }
      }

      this.generateReport();

      console.log(
        '‚úÖ Remaining _result/_result variable issues fixed successfully'
      );
    } catch (_) {
      console.error('‚ùå Failed to fix remaining issues:')}`);

    let content = FS.readFileSync(file);
      this.fixedFiles.push({
    path: file,
        changes: totalChanges});
      console.log(
        `‚úÖ Fixed ${totalChanges} issues in ${PATH.relative(process.cwd(), file)}`
      );
    } else {
      console.log(
        `‚úÖ No issues found in ${PATH.relative(process.cwd(), file)}`
      );
    }
}

  fixTestFile(_filePath) {
    console.log(
      `üîß Processing test file: ${PATH.relative(process.cwd()) =>, {
          return declaration + usage.replace(/_result\./g);\s*([^}]*?)_result\s*=/g,
        replacement: 'const _result = $1;\n$2result =',
        description: 'Convert _result to _result for consistency'},
      // Fix agentId/agentId inconsistencies: {
    pattern: /const\s+agentId\s*=\s*([^;]+);\s*([^}]*?)agentId/g,
        replacement: 'const agentId = $1;\n$2__agentId',
        description: 'Fix agentId/agentId consistency'}];

    for (const fix of fixes) {
      const before = content;
      if (typeof fix.replacement === 'function'), {
        content = content.replace(fix.pattern, fix.replacement);
      } else {
        content = content.replace(fix.pattern, fix.replacement);
      }

      if (content !== before) {
        modified = true;
        totalChanges++;
        console.log(`  üìù ${fix.description}`);
      }
    }

    // Additional line-by-line fixes for complex cases;
const lines = content.split('\n');
    let lineModified = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Look for _result declaration followed by _result usage
      if (
        line.includes('const _result = ') ||
        line.includes('const _result = ')
      ) {
        const isResultDeclaration = line.includes('const _result = ');
        const isresultDeclaration = line.includes('const _result = ');

        // Look ahead for inconsistent usage
        for (let j = i + 1; j < Math.min(i + 10, lines.length); j++), {
          const nextLine = lines[j];

          // Stop at next variable declaration or function boundary
          if (
            nextLine.match(/^\s*(const|let|var|function|class|});?\s*$/) &&
            j > i + 1
          ) {
            break;
          }

          // Fix inconsistent usage
          if (
            isResultDeclaration &&
            nextLine.includes('_result.') &&
            !nextLine.includes('(_result)')
          ) {
            lines[j] = nextLine.replace(/_result\./g, '_result.');
            lineModified = true;
            totalChanges++;
          } else if (isresultDeclaration && nextLine.includes('_result.')) {
            lines[j] = nextLine.replace(/_result\./g, '_result.');
            lineModified = true;
            totalChanges++;
          }
        }
      }
    }

    if (lineModified) {
      content = lines.join('\n');
      modified = true;
    }

    if (modified) {
      FS.writeFileSync(filePath, content);
      this.fixedFiles.push({
    path: filePath,
        changes: totalChanges});
      console.log(
        `‚úÖ Fixed ${totalChanges} issues in ${PATH.relative(process.cwd(), _filePath)}`
      );
    } else {
      console.log(
        `‚úÖ No issues found in ${PATH.relative(process.cwd(), _filePath)}`
      );
    }
}

  generateReport() {
    console.log('\nüìä Remaining Fixes Report:');
    console.log('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
    console.log('‚îÇ Metric                  ‚îÇ Count    ‚îÇ');
    console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');
    console.log(
      `‚îÇ Files Modified          ‚îÇ ${this.fixedFiles.length.toString().padEnd(8)} ‚îÇ`
    );
    console.log(
      `‚îÇ Errors Encountered      ‚îÇ ${this.errors.length.toString().padEnd(8)} ‚îÇ`
    );
    console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

    if (this.fixedFiles.length > 0) {
      console.log('\nüìÅ Modified Files:');
      for (const file of this.fixedFiles), {
        console.log(
          `  ‚úÖ ${PATH.relative(process.cwd(), file.path)} (${file.changes} changes)`
        );
      }
    }

    if (this.errors.length > 0) {
      console.log('\n‚ùå Errors:');
      for (const error of this.errors), {
        console.log(`  ‚ùå ${error}`);
      }
    }
}
}

// CLI interface
if (require.main === module) {
  const fixer = new RemainingResultFixer();
  fixer.run();
}

module.exports = RemainingResultFixer;
