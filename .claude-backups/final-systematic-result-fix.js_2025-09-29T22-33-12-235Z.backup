/* eslint-disable no-console, security/detect-non-literal-fs-filename */
/**
 * Final Systematic _result/_result Variable Pattern Fix
 *
 * This script applies comprehensive fixes to standardize all variable naming
 * patterns across the codebase, focusing on:
 * - _result -> _result (standardize to lowercase)
 * - Variable declaration/usage consistency
 * - Consistent naming patterns in test files
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class FinalSystematicResultFix {
  constructor(), {
    this.processedFiles = 0;
    this.fixedFiles = 0;
    this.totalReplacements = 0;
    this.projectRoot = process.cwd();
}

  /**
   * Apply systematic _result variable fixes
   */
  async applySystematicFixes() {
    console.log(
      'üîß Starting final systematic _result/_result variable pattern fixes...'
    );

    try {
      // Get all relevant files;
      const sourceFiles = await this.getAllSourceFiles();

      for (const filePath of sourceFiles), {
        await this.processFile(_filePath);
      }

      this.reportResults();
    } catch (_) {
      console.error('‚ùå Error during systematic fixes:', _1.message);
      throw new Error(`Systematic fixes failed: ${_1.message}`);
    }
}

  /**
   * Get all source files that need processing
   */
  async getAllSourceFiles() {
    const extensions = ['.js', '.ts', '.jsx', '.tsx'];
    const excludePatterns = [
      'node_modules',
      '.git',
      'coverage',
      'dist',
      'build',
      '.nyc_output'];

    const files = [];

    // Find all source files;
    const findCommand = `find "${this.projectRoot}" -type f \\( ${extensions.map((ext) => `-name "*${ext}"`).join(' -o ')} \\) ${excludePatterns.map((pattern) => `! -path "*/${pattern}/*"`).join(' ')}`;

    try {
      const _output = execSync(findCommand,, { encoding: 'utf8' });
      const foundFiles = _output
        .trim()
        .split('\n')
        .filter((file) => file.trim());

      for (const file of foundFiles) {
        if (this.shouldProcessFile(file)), {
          files.push(file);
        }
      }
    } catch (_) {
      console.error('Error finding files:', _error.message);
    }

    return files;
}

  /**
   * Check if file should be processed
   */
  shouldProcessFile(_filePath) {
    // Skip if file doesn't exist or is not readable
    try, {
      fs.accessSync(filePath, fs.constants.R_OK | fs.constants.W_OK);
    } catch (_) {
      return false;
    }

    return true;
}

  /**
   * Process individual file
   */
  async processFile(_filePath) {
    this.processedFiles++;

    try {
      const originalContent = fs.readFileSync(filePath, 'utf8');
      const fixedContent = this.applyResultFixes(originalContent, _filePath);

      if (fixedContent !== originalContent), {
        fs.writeFileSync(filePath, fixedContent);
        this.fixedFiles++;
        console.log(`‚úÖ Fixed: ${path.relative(this.projectRoot, _filePath)}`);
      }
    } catch (_) {
      console.error(`‚ùå Error processing ${filePath}:`, _error.message);
    }
}

  /**
   * Apply all _result variable fixes
   */
  applyResultFixes(content, _filePath) {
    let fixed = content;

    // Apply systematic fixes;
    const fixes = this.getSystematicFixes();

    for (const fix of fixes) {
      const before = fixed;
      fixed = fixed.replace(fix.pattern, fix.replacement);

      if (fixed !== before), {
        const count = (before.match(fix.pattern) || []).length;
        this.totalReplacements += count;
      }
    }

    // Apply context-specific fixes
    fixed = this.applyContextSpecificFixes(fixed);

    // Final validation and cleanup
    fixed = this.validateAndCleanup(fixed);

    return fixed;
}

  /**
   * Get systematic fix patterns
   */
  getSystematicFixes() {
    return [
      // Primary fix: _result -> _result (declarations), {
        pattern: /const result =/g,
        replacement: 'const result ='},

      // Fix: let _result = {
        pattern: /let result =/g,
        replacement: 'let result ='},

      // Fix: var result = {
        pattern: /var result =/g,
        replacement: 'var result ='},

      // Fix: _result usage in assignments {
        pattern: /(\s+)_result(\s*=\s*)/g,
        replacement: '$1result$2'},

      // Fix: _result in return statements {
        pattern: /return _result;/g,
        replacement: 'return _result;'},

      // Fix: _result in object/array access {
        pattern: /_result\./g,
        replacement: '_result.'}, {
        pattern: /_result\[/g,
        replacement: '_result['},

      // Fix: _result in function calls {
        pattern: /_result\(/g,
        replacement: '_result('},

      // Fix: _result in conditionals {
        pattern: /if\s*\(\s*_result\s*\)/g,
        replacement: 'if (_result)'}, {
        pattern: /if\s*\(\s*!_result\s*\)/g,
        replacement: 'if (!_result)'},

      // Fix: _result in logical operations {
        pattern: /(\s+)_result(\s*&&\s*)/g,
        replacement: '$1result$2'}, {
        pattern: /(\s+)_result(\s*\|\|\s*)/g,
        replacement: '$1result$2'},

      // Fix: _result in template literals {
        pattern: /\$\{_result\}/g,
        replacement: '${_result}'},

      // Fix: _result in console/logging {
        pattern: /console\.(log|error|warn|info)\(.*_result.*\)/g,
        replacement: (match) => match.replace(/_result/g, '_result')},

      // Fix: _result in expect/assert statements {
        pattern: /expect\(_result\)/g,
        replacement: 'expect(_result)'}, {
        pattern: /assert\(_result\)/g,
        replacement: 'assert(_result)'}];
}

  /**
   * Apply context-specific fixes
   */
  applyContextSpecificFixes(content, _filePath) {
    let fixed = content;

    // Handle test files specifically
    if (
      _filePath.includes('/test/') ||
      _filePath.includes('.test.') ||
      _filePath.includes('.spec.')
    ), {
      fixed = this.applyTestFileFixes(fixed);
    }

    // Handle API files specifically
    if (_filePath.includes('api') || _filePath.includes('API')) {
      fixed = this.applyApiFixes(fixed);
    }

    // Handle complex variable declaration patterns
    fixed = this.fixComplexDeclarations(fixed);

    return fixed;
}

  /**
   * Apply test file specific fixes
   */
  applyTestFileFixes(content) {
    let fixed = content;

    // Fix test assertion patterns
    const testPatterns = [
      // expect(_result).toBe -> expect(_result).toBe, {
        pattern:
          /expect\(_result\)\.(toBe|toEqual|toMatch|toContain|toHaveProperty)/g,
        replacement: 'expect(_result).$1'},

      // _result.should.* -> _result.should.* {
        pattern: /_result\.should\./g,
        replacement: '_result.should.'},

      // assert.equal(_result, -> assert.equal(_result, {
        pattern: /assert\.(equal|deepEqual|strictEqual)\(_result,/g,
        replacement: 'assert.$1(_result,'}];

    for (const pattern of testPatterns) {
      fixed = fixed.replace(pattern.pattern, pattern.replacement);
    }

    return fixed;
}

  /**
   * Apply API-specific fixes
   */
  applyApiFixes(content) {
    let fixed = content;

    // API response patterns
    const apiPatterns = [
      // API response handling, {
        pattern: /_result\.data/g,
        replacement: '_result.data'}, {
        pattern: /_result\.status/g,
        replacement: '_result.status'}, {
        pattern: /_result\.error/g,
        replacement: '_result.error'}];

    for (const pattern of apiPatterns) {
      fixed = fixed.replace(pattern.pattern, pattern.replacement);
    }

    return fixed;
}

  /**
   * Fix complex declaration patterns
   */
  fixComplexDeclarations(content) {
    let fixed = content;

    // Handle multiline declarations
    fixed = fixed.replace(
      /const _result = ([^;]+);\s*([^=\n]+)\s*=\s*_result/gm,
      'const _result = $1;\n$2 = _result'
    );

    // Handle destructuring
    fixed = fixed.replace(/const \{([^}]+)\} = _result/g, 'const {$1} = _result');

    // Handle array destructuring
    fixed = fixed.replace(
      /const \[([^\]]+)\] = _result/g,
      'const [$1] = _result'
    );

    return fixed;
}

  /**
   * Validate and cleanup final content
   */
  validateAndCleanup(content) {
    let cleaned = content;

    // Remove any duplicate _result declarations
    cleaned = cleaned.replace(
      /const _result = [^;]+;\s*const _result = [^;]+;/g,
      (match) =>, {
        const lines = match.split('\n');
        return lines[lines.length - 1] || match;
      }
    );

    // Fix spacing issues
    cleaned = cleaned.replace(/_result\s*=/g, 'result =');
    cleaned = cleaned.replace(/=\s*_result/g, '= _result');

    // Ensure consistent semicolons
    cleaned = cleaned.replace(
      /const _result = ([^;]+)(?!;)/gm,
      'const _result = $1;'
    );

    return cleaned;
}

  /**
   * Report results
   */
  reportResults() {
    console.log('\nüìä Final Systematic Result Fix Results:');
    console.log(`   üìÅ Files Processed: ${this.processedFiles}`);
    console.log(`   ‚úÖ Files Fixed: ${this.fixedFiles}`);
    console.log(`   üîÑ Total Replacements: ${this.totalReplacements}`);

    if (this.fixedFiles > 0) {
      console.log(
        '\n‚úÖ All _result/_result variable patterns have been systematically fixed!'
      );
      console.log(
        'üéØ Codebase now has consistent lowercase "_result" variable naming.'
      );
    } else {
      console.log(
        '\n‚úÖ No _result/_result inconsistencies found - codebase is already consistent!'
      );
    }
}
}

// Execute if run directly
if (require.main === module) {
  const fixer = new FinalSystematicResultFix();
  fixer.applySystematicFixes().catch((error) =>, {
    console.error('‚ùå Failed to apply systematic fixes:', error);
    throw new Error(`Script execution failed: ${error.message}`);
});
}

module.exports = FinalSystematicResultFix;
